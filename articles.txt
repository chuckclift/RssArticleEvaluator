<article>
100,000 integrated circuits with a Japanese manufacturer. Part of the
specification was the defect rate: one chip in 10,000. A few weeks later
the order arrived: one large box containing thousands of ICs, and a
small one containing just ten. Attached to the small box was a label
that read: “These are the faulty ones.”
Prepared exclusively for Zach
10 CHAPTER1 APRAGMATIC PHILOSOPHY
If only we really had this kind of control over quality. But the real
world just won’t let us produce much that’s truly perfect, particularly
not bug-free software. Time, technology, and temperament all conspire
against us.
However, this doesn’t have to be frustrating. As Ed Yourdon described
in an article in IEEE Software [You95], you can discipline yourself to
write software that’s good enough—good enough for your users, for future
maintainers, for your own peace of mind. You’ll find that you are
more productive and your users are happier. And you may well find
that your programs are actually better for their shorter incubation.
</article>
<article>

Before we go any further, we need to qualify what we’re about to say.
The phrase “good enough” does not imply sloppy or poorly produced
code. All systems must meet their users’ requirements to be successful.
We are simply advocating that users be given an opportunity to
participate in the process of deciding when what you’ve produced is
good enough.
Involve Your Users in the Trade



requirements from them.2 But how often do you ask them
how good they want their software to be? Sometimes there’ll be no
choice. If you’re working on pacemakers, the space shuttle, or a lowlevel
library that will be widely disseminated, the requirements will
be more stringent and your options more limited. However, if you’re
working on a brand new product, you’ll have different constraints. The
marketing people will have promises to keep, the eventual end users
may have made plans based on a delivery schedule, and your company
will certainly have cash-flow constraints. It would be unprofessional to
ignore these users’ requirements simply to add new features to the program,
or to polish up the code just one more time. We’re not advocating
panic: it is equally unprofessional to promise impossible time scales
and to cut basic engineering corners to meet a deadline.
2. That was supposed to be a joke!
Prepared exclusively for Zach
GOOD-ENOUGH SOFTWARE 11
The scope and quality of the system you produce should be specified
as part of that system’s requirements.
TIP 7
Make Quality a Requirements Issue
Often you’ll be in situations where trade-offs are involved. Surprisingly,
many users would rather use software with some rough edges today
than wait a year for the multimedia version. Many IT departments with
tight budgets would agree. Great software today is often preferable to
perfect software tomorrow. If you give your users something to play with
early, their feedback will often lead you to a better eventual solution (see
Tracer Bullets, page 48).
Know When to Stop
</article>
<article>
In some ways, programming is like painting. You start with a blank
canvas and certain basic raw materials. You use a combination of science,
art, and craft to determine what to do with them. You sketch
out an overall shape, paint the underlying environment, then fill in the
details. You constantly step back with a critical eye to view what you’ve
done. Every now and then you’ll throw a canvas away and start again.
But artists will tell you that all the hard work is ruined if you don’t
know when to stop. If you add layer upon layer, detail over detail, the
painting becomes lost in the paint.
Don’t spoil a perfectly good program by overembellishment and overrefinement.
Move on, and let your code stand in its own right for a
while. It may not be perfect. Don’t worry: it could never be perfect. (In
Chapter 6, page 171, we’ll discuss philosophies for developing code in
an imperfect world.)
Related sections include:
Tracer Bullets, page 48
The Requirements Pit, page 202
Pragmatic Teams, page 224
Great Expectations, page 255
Prepared exclusively for Zach
12 CHAPTER1 APRAGMATIC PHILOSOPHY
Challenges
Look at the manufacturers of the software tools and operating systems that
you use. Can you find any evidence that these companies are comfortable
shipping software they know is not perfect? As a user, would you rather
(1) wait for them to get all the bugs out, (2) have complex software and
accept some bugs, or (3) opt for simpler software with fewer defects?
Consider the effect of modularization on the delivery of software. Will it
take more or less time to get a monolithic block of software to the required
quality compared with a system designed
</article>